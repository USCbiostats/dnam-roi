---
title: "Multi_CTCF_Motif_4group"
output: html_document
date: "2024-12-18"
---


```{r libraries, message=FALSE,warning=FALSE}

library(data.table)
library(Biostrings)
library(ComplexHeatmap)
library(ggplot2)
library(knitr)
library(kableExtra)
library(dplyr)
library(GenomeInfoDb)
library(rtracklayer)
library(GenomicRanges)
```


```{r}
# List of cancer types in order
cancer_list <- c("COAD", "BLCA", "BRCA", "GBM", "KIRC", "KIRP", "LUAD", "SKCM")

# Initialize a list to store the merged CTCF intervals for each cancer
ctcf_merged_list <- list()

# Step 1: Import and Process Motif Data for Each Cancer
for (cancer in cancer_list) {
  # Construct the file path
  file_path <- paste0("data/", cancer, "_cleaned_motifs.csv")
  
  # Read the motif data
  motif_data <- fread(file_path, header = TRUE)
  
  # Ensure column names are correct
  if (!all(c("seqnames", "start", "end", "group_name") %in% colnames(motif_data))) {
    colnames(motif_data) <- c("seqnames", "start", "end", "group_name")
  }
  
  # Filter to keep only CTCF group
  ctcf_data <- motif_data %>%
    filter(group_name == "CTCF")
  
  # Check if any data is present
  if (nrow(ctcf_data) == 0) {
    message("No CTCF motifs found in ", cancer)
    ctcf_merged_list[[cancer]] <- GRanges()  # Store an empty GRanges object
    next
  }
  
  # Adjust motif start positions for 1-based coordinates if necessary
  # Uncomment the following line if your data is 0-based
  # ctcf_data$start <- ctcf_data$start + 1  # Convert start to 1-based coordinates
  
  # Create GRanges object for CTCF motifs
  ctcf_gr <- GRanges(
    seqnames = ctcf_data$seqnames,
    ranges = IRanges(start = ctcf_data$start, end = ctcf_data$end)
  )
  
  # Ensure consistent chromosome naming
  seqlevelsStyle(ctcf_gr) <- "UCSC"
  
  # Merge overlapping intervals
  ctcf_gr_merged <- reduce(ctcf_gr)
  
  # Store the merged intervals in the list
  ctcf_merged_list[[cancer]] <- ctcf_gr_merged
}


############################################
## 1. Define the 4 Disjoint Groups
############################################

## 1a) common_all_8 => intersection of all 8
grl_all <- GRangesList(ctcf_merged_list[cancer_list])
common_all_8 <- Reduce(intersect, grl_all)

## 1b) coad_only => intervals in COAD that are absent from any of the other 7
coad <- ctcf_merged_list[["COAD"]]
others <- setdiff(cancer_list, "COAD")
# Union of the other 7
grl_others <- GRangesList(ctcf_merged_list[others])
union_others <- unlist(grl_others, use.names = FALSE)
union_others <- reduce(union_others)
coad_only <- GenomicRanges::setdiff(coad, union_others)

## 1c) all_w_o_coad => intervals in the union of the other 7 but not in COAD
all_w_o_coad <- GenomicRanges::setdiff(union_others, coad)

## 1d) coad_plus_others (but not in all 8)
##     i.e. intervals that appear in COAD + at least one other, but not in all 8
## Approach: take the union of (coad + union_others), then remove coad_only (just COAD),
## remove all_w_o_coad (only in others), remove common_all_8 (in all 8).
coad_union_others <- c(coad, union_others)  # GRanges combine
coad_union_others <- reduce(coad_union_others)

# Remove coad_only, all_w_o_coad, common_all_8
temp <- GenomicRanges::setdiff(coad_union_others, coad_only)
temp <- GenomicRanges::setdiff(temp, all_w_o_coad)
coad_plus_others <- GenomicRanges::setdiff(temp, common_all_8)

############################################
## 2. Prepare the 4 Groups in a Named List
############################################
ctcf_4groups <- list(
  "common_all_8"    = common_all_8,
  "coad_plus_others" = coad_plus_others,
  "coad_only"       = coad_only,
  "all_w_o_coad"    = all_w_o_coad
)

```


```{r}
# example show the difference setdiff(intersect function) / seq overlaps
```

```{r}
# joint coverage check

# Suppose you have:
# 1) common_all_8
# 2) coad_only
# 3) all_w_o_coad
# 4) coad_plus_others
# And union_all_8 is the union of all 8 cancers.

## Pairwise intersections should be zero in length:
stopifnot(length(GenomicRanges::intersect(common_all_8, coad_only)) == 0)
stopifnot(length(GenomicRanges::intersect(common_all_8, all_w_o_coad)) == 0)
stopifnot(length(GenomicRanges::intersect(common_all_8, coad_plus_others)) == 0)
stopifnot(length(GenomicRanges::intersect(coad_only, all_w_o_coad)) == 0)
stopifnot(length(GenomicRanges::intersect(coad_only, coad_plus_others)) == 0)
stopifnot(length(GenomicRanges::intersect(all_w_o_coad, coad_plus_others)) == 0)

## Combined four group sets vs union of all 8
four_combined <- c(common_all_8, coad_only, all_w_o_coad, coad_plus_others)
four_combined <- reduce(four_combined)

# ## Then compare with union_all_8
stopifnot(length(GenomicRanges::setdiff(coad_union_others, four_combined)) == 0)
stopifnot(length(GenomicRanges::setdiff(four_combined, coad_union_others)) == 0)

```


```{r}

############################################
## 3. Load Methylation Data for DA and DB
############################################
## We do the same approach as before for pairwise analysis.

# Load DA
meth_data_DA <- fread("data/DA.bed", header = FALSE)
colnames(meth_data_DA) <- c("chrom", "start", "end", "beta", "coverage", "methylated", "unmethylated")
meth_gr_DA <- GRanges(
  seqnames = meth_data_DA$chrom,
  ranges = IRanges(start = meth_data_DA$start, end = meth_data_DA$end),
  beta = meth_data_DA$beta,
  coverage = meth_data_DA$coverage,
  methylated = meth_data_DA$methylated,
  unmethylated = meth_data_DA$unmethylated
)
seqlevelsStyle(meth_gr_DA) <- "UCSC"

# Load DB
meth_data_DB <- fread("data/DB.bed", header = FALSE)
colnames(meth_data_DB) <- c("chrom", "start", "end", "beta", "coverage", "methylated", "unmethylated")
meth_gr_DB <- GRanges(
  seqnames = meth_data_DB$chrom,
  ranges = IRanges(start = meth_data_DB$start, end = meth_data_DB$end),
  beta = meth_data_DB$beta,
  coverage = meth_data_DB$coverage,
  methylated = meth_data_DB$methylated,
  unmethylated = meth_data_DB$unmethylated
)
seqlevelsStyle(meth_gr_DB) <- "UCSC"

############################################
## 4. Summarize Methylation for DA
############################################
summary_list_DA <- list()
for (group_name in names(ctcf_4groups)) {
  gr_group <- ctcf_4groups[[group_name]]
  
  if (length(gr_group) == 0) next  # no intervals

  hits <- findOverlaps(gr_group, meth_gr_DA)
  if (length(hits) == 0) next

  ctcf_idx <- queryHits(hits)
  meth_idx <- subjectHits(hits)
  meth_overlaps <- meth_gr_DA[meth_idx]
  
  # Assign group
  mcols(meth_overlaps)$ctcf_idx <- paste0(group_name, "_", ctcf_idx)
  mcols(meth_overlaps)$cancer_type <- group_name
  
  dt <- as.data.table(mcols(meth_overlaps))
  dt$depth <- dt$coverage
  dt$filtbeta <- ifelse(dt$depth > 4, dt$beta, NA)
  dt$lowdepth <- ifelse(dt$depth < 5, 1, 0)
  
  dt <- dt[order(ctcf_idx)]
  
  sum_dt <- dt[, .(
    nCpG = .N,
    avg_filtbeta = mean(filtbeta, na.rm = TRUE),
    uncovered = sum(lowdepth),
    summ = sum(methylated),
    sum_coverage = sum(coverage)
  ), by = ctcf_idx]
  
  sum_dt$poolbeta <- sum_dt$summ / sum_dt$sum_coverage
  sum_dt$cancer_type <- group_name
  summary_list_DA[[group_name]] <- sum_dt
}

all_summary_DA <- rbindlist(summary_list_DA, fill = TRUE)

## Convert nCpG > 5 to "6+"
all_summary_DA$numCpG <- ifelse(all_summary_DA$nCpG > 5, "6+", as.character(all_summary_DA$nCpG))
all_summary_DA$numCpG <- factor(all_summary_DA$numCpG, levels = c("1", "2", "3", "4", "5", "6+"))

############################################
## 5. Summarize Methylation for DB
############################################
summary_list_DB <- list()
for (group_name in names(ctcf_4groups)) {
  gr_group <- ctcf_4groups[[group_name]]
  
  if (length(gr_group) == 0) next

  hits <- findOverlaps(gr_group, meth_gr_DB)
  if (length(hits) == 0) next

  ctcf_idx <- queryHits(hits)
  meth_idx <- subjectHits(hits)
  meth_overlaps <- meth_gr_DB[meth_idx]
  
  # Assign group
  mcols(meth_overlaps)$ctcf_idx <- paste0(group_name, "_", ctcf_idx)
  mcols(meth_overlaps)$cancer_type <- group_name
  
  dt <- as.data.table(mcols(meth_overlaps))
  dt$depth <- dt$coverage
  dt$filtbeta <- ifelse(dt$depth > 4, dt$beta, NA)
  dt$lowdepth <- ifelse(dt$depth < 5, 1, 0)
  
  dt <- dt[order(ctcf_idx)]
  
  sum_dt <- dt[, .(
    nCpG = .N,
    avg_filtbeta = mean(filtbeta, na.rm = TRUE),
    uncovered = sum(lowdepth),
    summ = sum(methylated),
    sum_coverage = sum(coverage)
  ), by = ctcf_idx]
  
  sum_dt$poolbeta <- sum_dt$summ / sum_dt$sum_coverage
  sum_dt$cancer_type <- group_name
  summary_list_DB[[group_name]] <- sum_dt
}

all_summary_DB <- rbindlist(summary_list_DB, fill = TRUE)

all_summary_DB$numCpG <- ifelse(all_summary_DB$nCpG > 5, "6+", as.character(all_summary_DB$nCpG))
all_summary_DB$numCpG <- factor(all_summary_DB$numCpG, levels = c("1", "2", "3", "4", "5", "6+"))

############################################
## 6. Pairwise Difference Analysis
############################################
# Similar to your previous code

# Rename columns in all_summary_DB to avoid conflicts
cn <- colnames(all_summary_DB)
columns_to_rename <- setdiff(cn, c("ctcf_idx", "cancer_type"))
cn_new <- cn
cn_new[cn %in% columns_to_rename] <- paste0("s2.", cn[cn %in% columns_to_rename])
colnames(all_summary_DB) <- cn_new

# Merge on ctcf_idx, cancer_type
pairsDt <- merge(all_summary_DA, all_summary_DB, by = c("ctcf_idx", "cancer_type"))

# Compute pairwise differences
pairsDt$pwd <- abs(pairsDt$poolbeta - pairsDt$s2.poolbeta)
```

```{r}

# Prepare data for plotting
pairsDt$numCpG <- ifelse(pairsDt$nCpG > 5, "6+", as.character(pairsDt$nCpG))
pairsDt$numCpG <- factor(pairsDt$numCpG, levels = c("1", "2", "3", "4", "5", "6+"))

# Provide short abbreviations for the 4 groups
abbrev_labels <- c(
  "common_all_8" = "All8",
  "coad_only" = "C-only",
  "coad_plus_others" = "C+others",
  "all_w_o_coad" = "All-w/o-C"
)

pairsDt$cancer_type_abbrev <- abbrev_labels[pairsDt$cancer_type]
pairsDt$cancer_type_abbrev <- factor(pairsDt$cancer_type_abbrev, levels = abbrev_labels)

############################################
## 7. Plot the Pairwise Differences (pwd)
############################################
filtered_pairsDt <- pairsDt[
  pairsDt$sum_coverage > 4 & pairsDt$s2.sum_coverage > 4 &
  !is.na(pairsDt$pwd) & is.finite(pairsDt$pwd),
]

numCpG_values <- levels(filtered_pairsDt$numCpG)

for (numCpG_value in numCpG_values) {
  plot_data_subset <- filtered_pairsDt[filtered_pairsDt$numCpG == numCpG_value, ]
  
  if (nrow(plot_data_subset) == 0) {
    message("No data available for numCpG = ", numCpG_value)
    next
  }
  
  y_max <- max(plot_data_subset$pwd, na.rm = TRUE)
  y_limit <- min(y_max, 0.4)  # Example: cap at 1
  
  p <- ggplot(plot_data_subset, aes(x = cancer_type_abbrev, y = pwd, fill = cancer_type_abbrev)) +
    geom_violin() +
    stat_summary(fun = mean, geom = "point", shape = 23, size = 2, color = "black") +
    stat_summary(fun = median, geom = "point", size = 2, color = "red") +
    ylim(0, y_limit) +
    labs(
      title = paste("PWD: DA - DB - numCpG =", numCpG_value),
      x = "Group",
      y = "Pairwise Difference (PWD)"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
      axis.title = element_text(size = 12),
      plot.title = element_text(size = 14, face = "bold"),
      legend.position = "none"
    )
  
  print(p)
  # Optionally, ggsave(...) if you want to save the plots
}
```

```{r}
## Linear regression analysis

# 'pairsDt' is assumed to contain:
# - pwd: the pairwise difference (DA vs. DB)
# - cancer_type: factor or character with values {coad_only, common_all_8, coad_plus_others, all_w_o_coad}
# - nCpG: number of CpGs (factor or numeric)
# - sum_coverage, s2.sum_coverage: coverage columns for DA/DB
# - plus any other columns needed

# Convert 'cancer_type' to factor with desired baseline
pairsDt$cancer_type <- factor(
  pairsDt$cancer_type,
  levels = c("common_all_8", "coad_only", "coad_plus_others", "all_w_o_coad")
)

# Create a numeric variable for nCpG if needed
pairsDt$nCpG_numeric <- as.numeric(as.character(pairsDt$nCpG))

# We only want rows where coverage >=5 in both DA/DB,
# and where 'pwd' is finite and not NA.
# This yields a logical vector for indexing.

ft_idx <- which(
  pairsDt$sum_coverage > 4 & 
  pairsDt$s2.sum_coverage > 4 &
  !is.na(pairsDt$pwd) & 
  is.finite(pairsDt$pwd)
)

lm_model <- lm(
  pwd ~ cancer_type + nCpG_numeric, 
  data = pairsDt, 
  subset = ft_idx
)

lm_result <- summary(lm_model)
print(lm_result)


############################################
## 3) Interpreting the Model
############################################
# - (Intercept): predicted PWD for the baseline TFBS group (coad_only) at nCpG_numeric = 0 (if that’s feasible)
# - TFBS_groupXXX: difference in PWD relative to the baseline group
# - nCpG_numeric: slope representing how PWD changes with each additional CpG
#
# If p-values are small => statistically significant difference from baseline or slope ≠ 0.

```

```{r}
## 2a) Convert 'cancer_type' to a factor with a desired baseline if needed
pairsDt$cancer_type <- factor(
  pairsDt$cancer_type,
  levels = c("coad_only", "common_all_8", "coad_plus_others", "all_w_o_coad")
)

# ############################################
## 3) Filter out intervals not meeting coverage or finite 'pwd'
############################################
filtered_pairsDt <- pairsDt %>%
  filter(
    sum_coverage > 4,
    s2.sum_coverage > 4,
    !is.na(pwd),
    is.finite(pwd)
  )

############################################
## 4) Summarize average PWD for each group
############################################
pwd_summary <- filtered_pairsDt %>%
  group_by(cancer_type) %>%
  summarise(
    n_intervals = n(),               # How many intervals in this group after filtering
    avg_pwd = mean(pwd, na.rm = TRUE)  # Average PWD
  ) %>%
  arrange(avg_pwd)  # Optional: sort by ascending average PWD

# Print the summary
print(pwd_summary)
```


```{r}
# obtain the FIMO-intervals
suppressMessages(library(AnnotationHub))
ah <- AnnotationHub()
query_data <- subset(ah, preparerclass == "CTCF")

# Explore the AnnotationHub object
query_data
query_data$dataprovider %>% table()

subset(query_data, species == "Homo sapiens" & 
                   genome == "hg38" & 
                   dataprovider == "JASPAR 2022")

# CTCF-all motifs (FIMO)
CTCF_hg38_all <- query_data[["AH104727"]]
CTCF_hg38_reduce = reduce(CTCF_hg38_all)
CTCF_hg38_reduce
```

```{r}
coad_only$ctcf_idx <- paste0("coad_only_", seq_along(coad_only))
common_all_8$ctcf_idx <- paste0("common_all_8_", seq_along(common_all_8))
coad_plus_others$ctcf_idx <- paste0("coad_plus_others_", seq_along(coad_plus_others))
all_w_o_coad$ctcf_idx <- paste0("all_w_o_coad_", seq_along(all_w_o_coad))

# mcols(coad_only)
# mcols(common_all_8)
# mcols(coad_plus_others)
# mcols(all_w_o_coad)

```

```{r}
############################################################
## 0. Load Packages & Prepare Objects
############################################################


# Assume you have:
#   1) coad_only, common_all_8, coad_plus_others, all_w_o_coad
#      Each is a GRanges object with a 'ctcf_idx' metadata column
#      e.g.: coad_only$ctcf_idx, etc.
#
#   2) FIMO intervals in a GRanges: CTCF_hg38_reduce
#   3) Methylation data for DA in meth_gr_DA
#   4) Methylation data for DB in meth_gr_DB
#
# All with consistent seqlevelsStyle(...)= "UCSC" if needed.

############################################################
## 1. (Optional) Filter the Four Groups by FIMO Overlap
##    If you do NOT want to apply the FIMO filter, skip this step
############################################################
filter_by_fimo <- function(gr, fimo_gr) {
  if (length(gr) == 0) return(GRanges())
  hits <- findOverlaps(gr, fimo_gr)
  keep_idx <- unique(queryHits(hits))
  gr[keep_idx]
}

# If you want to filter by FIMO:
coad_only_fimo        <- filter_by_fimo(coad_only, CTCF_hg38_reduce)
common_all_8_fimo     <- filter_by_fimo(common_all_8, CTCF_hg38_reduce)
coad_plus_others_fimo <- filter_by_fimo(coad_plus_others, CTCF_hg38_reduce)
all_w_o_coad_fimo     <- filter_by_fimo(all_w_o_coad, CTCF_hg38_reduce)

# ...or if you want the unfiltered sets, you can just keep the original objects.
# For demonstration, let's use the FIMO-filtered versions:
coad_only_gr        <- coad_only_fimo
common_all_8_gr     <- common_all_8_fimo
coad_plus_others_gr <- coad_plus_others_fimo
all_w_o_coad_gr     <- all_w_o_coad_fimo

############################################################
## 2. A Helper Function to Summarize Methylation Data
##    For a Single Group (DA or DB)
############################################################
summarize_meth_for_group <- function(gr_group, meth_gr) {
  if (length(gr_group) == 0) return(data.table())

  hits <- findOverlaps(gr_group, meth_gr)
  if (length(hits) == 0) return(data.table())

  grp_idx <- queryHits(hits)      # index into gr_group
  meth_idx <- subjectHits(hits)   # index into meth_gr

  # Extract overlap methylation data
  meth_overlaps <- meth_gr[meth_idx]
  
  # Keep ctcf_idx from the intervals
  # (assuming the intervals have ctcf_idx in mcols)
  mcols(meth_overlaps)$ctcf_idx <- gr_group$ctcf_idx[grp_idx]
  
  # Convert to data.table
  dt <- as.data.table(mcols(meth_overlaps))
  
  # If coverage is stored in dt$coverage, let's define dt$depth
  dt$depth <- dt$coverage
  
  # Summarize by ctcf_idx
  sum_dt <- dt[, .(
    nCpG = .N,
    summ = sum(methylated),     # sum of methylated reads
    sum_coverage = sum(coverage),
    # You can also store other stats if you want
    uncovered = sum(depth < 5)
  ), by = ctcf_idx]

  # poolbeta
  sum_dt$poolbeta <- sum_dt$summ / sum_dt$sum_coverage

  sum_dt
}

############################################################
## 3. For Each Group, Summarize DA & DB, Then Merge & Compute PWD
############################################################
compute_pwd_for_group <- function(gr_group, meth_gr_DA, meth_gr_DB, group_name) {
  # Summarize DA
  da_dt <- summarize_meth_for_group(gr_group, meth_gr_DA)
  colnames(da_dt) <- c("ctcf_idx", "nCpG", "summ", "sum_coverage", "uncovered", "poolbeta")
  # rename columns to avoid conflict
  colnames(da_dt)[3:6] <- paste0("da.", colnames(da_dt)[3:6])

  # Summarize DB
  db_dt <- summarize_meth_for_group(gr_group, meth_gr_DB)
  colnames(db_dt) <- c("ctcf_idx", "nCpG", "summ", "sum_coverage", "uncovered", "poolbeta")
  colnames(db_dt)[3:6] <- paste0("db.", colnames(db_dt)[3:6])

  # Merge on ctcf_idx
  merged_dt <- merge(da_dt, db_dt, by = c("ctcf_idx", "nCpG"), all = FALSE)

  # Compute pairwise difference
  merged_dt$pwd <- abs(merged_dt$da.poolbeta - merged_dt$db.poolbeta)

  # Optionally compute Brown & Li's 95% CI if you want
  p1prime <- (merged_dt$da.summ + 0.5) / (merged_dt$da.sum_coverage + 1)
  p2prime <- (merged_dt$db.summ + 0.5) / (merged_dt$db.sum_coverage + 1)
  varp1prime <- p1prime * (1 - p1prime) / merged_dt$da.sum_coverage
  varp2prime <- p2prime * (1 - p2prime) / merged_dt$db.sum_coverage
  sddiff <- sqrt(varp1prime + varp2prime)
  merged_dt$ubdiff <- abs(p1prime - p2prime) + 1.96 * sddiff
  
  # Add group label
  merged_dt$cancer_type <- group_name

  merged_dt
}

############################################################
## 4. Put It All Together for the 4 Groups
############################################################
pairs_list <- list()

pairs_list[["common_all_8"]]    <- compute_pwd_for_group(common_all_8_gr, meth_gr_DA, meth_gr_DB, "common_all_8")
pairs_list[["coad_only"]]       <- compute_pwd_for_group(coad_only_gr, meth_gr_DA, meth_gr_DB, "coad_only")
pairs_list[["coad_plus_others"]]<- compute_pwd_for_group(coad_plus_others_gr, meth_gr_DA, meth_gr_DB, "coad_plus_others")
pairs_list[["all_w_o_coad"]]    <- compute_pwd_for_group(all_w_o_coad_gr, meth_gr_DA, meth_gr_DB, "all_w_o_coad")

pairsDt_final <- rbindlist(pairs_list, fill = TRUE)

############################################################
## 5. Filter Coverage if Desired, Then Summarize
############################################################
pairsDt_final_filtered <- pairsDt_final[
  da.sum_coverage > 4 & db.sum_coverage > 4 & 
  !is.na(pwd) & is.finite(pwd)
]

# Summarize average PWD for each group
fimo_pwd_summary <- pairsDt_final_filtered %>%
  group_by(cancer_type) %>%
  summarize(
    n_intervals = n(),
    avg_pwd = mean(pwd, na.rm = TRUE)
    # ... you can store avg ubdiff or other stats
  ) %>%
  arrange(avg_pwd)

print(fimo_pwd_summary)
```

```{r}
four_combined <- c(common_all_8, coad_only, all_w_o_coad, coad_plus_others)

four_combined_sum <- length(common_all_8) + length(coad_only) + length(all_w_o_coad) + length(coad_plus_others)

print((length(four_combined)))
print(four_combined_sum)

four_combined_fimo <- reduce(c(common_all_8_fimo, coad_only_fimo, all_w_o_coad_fimo, coad_plus_others_fimo))
print((length(four_combined_fimo)))
```

```{r}
overlapping_segments <- GenomicRanges::intersect(union_others, CTCF_hg38_reduce)
print(length(overlapping_segments))
# Each record in the result is physically the overlapped region
```

```{r}
############################################
## 1) Rename columns in each table
############################################
pwd_summary_renamed <- pwd_summary %>%
  dplyr::rename(
    TFBS_group     = cancer_type,
    intervals_orig = n_intervals,
    avg_pwd_orig   = avg_pwd
  )


fimo_pwd_summary_renamed <- fimo_pwd_summary %>%
  dplyr::rename(
    TFBS_group     = cancer_type,
    intervals_fimo = n_intervals,
    avg_pwd_fimo   = avg_pwd
  )

############################################
## 2) Merge by TFBS_group
############################################
combined_df <- merge(
  pwd_summary_renamed,
  fimo_pwd_summary_renamed,
  by = "TFBS_group",
  all = TRUE
)

############################################
## 3) Compute % change in average PWD
############################################
## e.g. percent change = 100 * (avg_pwd_fimo - avg_pwd_orig)/avg_pwd_orig
combined_df$percent_change_pwd <- with(
  combined_df,
  ifelse(
    avg_pwd_orig == 0,
    NA_real_,
    100 * (avg_pwd_fimo - avg_pwd_orig) / avg_pwd_orig
  )
)

desired_order <- c(
  "common_all_8",
  "coad_plus_others",
  "coad_only",
  "all_w_o_coad"
)

# Convert TFBS_group to a factor with the desired levels
combined_df$TFBS_group <- factor(combined_df$TFBS_group, levels = desired_order)

# Reorder rows by TFBS_group
combined_df <- combined_df[order(combined_df$TFBS_group), ]
############################################
## 4) Print or Save the Final Table
############################################
print(combined_df)

## Optionally save as CSV
# write.csv(combined_df, "pwd_fimo_comparison.csv", row.names = FALSE)

```




```{r}
library(dplyr)
library(ggplot2)

########################################
## 1) Prepare Data
########################################
# Suppose you have a data frame 'pairsDt' with columns:
#   - 'nCpG': integer number of CpGs
#   - 'pwd': the pairwise difference
#   - 'sum_coverage', 's2.sum_coverage' if you want coverage filters
#   etc.

plot_data <- pairsDt %>%
  # (Optional coverage filter)
  filter(
    sum_coverage > 4,
    s2.sum_coverage > 4,
    !is.na(pwd),
    is.finite(pwd)
  ) %>%
  mutate(
    # Turn any interval >5 into "6+"
    nCpG_factor = ifelse(nCpG > 5, "6+", as.character(nCpG))
  ) %>%
  mutate(
    # Make it an ordered factor with levels 1,2,3,4,5,6+
    nCpG_factor = factor(nCpG_factor, levels = c("1", "2", "3", "4", "5", "6+"))
  )

########################################
## 2) Count # intervals in each bin
########################################
counts_data <- plot_data %>%
  group_by(nCpG_factor) %>%
  summarise(n_intervals = n())

# Create a named vector so we can use it in scale_x_discrete
counts_vec <- setNames(counts_data$n_intervals, counts_data$nCpG_factor)

# Build custom axis labels, e.g. "1 (n=1234)"
axis_labels <- paste0(
  levels(plot_data$nCpG_factor),
  "\n(n=",
  counts_vec[levels(plot_data$nCpG_factor)],
  ")"
)

########################################
## 3) Violin Plot
########################################
ggplot(plot_data, aes(x = nCpG_factor, y = pwd)) +
  geom_violin(fill = "skyblue", alpha = 0.5) +
  
  # Add a black square for mean
  stat_summary(fun = mean, geom = "point", shape = 22, size = 2, fill = "black", color = "black") +
  
  # Add a red circle for median
  stat_summary(fun = median, geom = "point", size = 3, color = "red") +
  
  # X-axis ticks show the bin label plus (n=?)
  scale_x_discrete(labels = axis_labels) +
  
  labs(
    x = "# of CpGs in Interval",
    y = "Pairwise Difference (PWD)",
    title = "PWD by Number of CpGs (DA-DB)"
  ) +
  
  theme_minimal()

```

```{r}
library(GenomicRanges)
library(dplyr)
library(tidyr)

############################################
## 1) Suppose you already computed the stats for:
##    all_w_o_coad, coad_only, coad_plus_others, common_all_8
##    using get_fimo_overlap_stats() or similar.
############################################

## We'll assume you have something like 'table_list' with 4 data frames, 
## each has columns:
##   TFBS_group, intervals, pct_of_total, fimo_overlap, pct_fimo_total, ...
## Then you rbind into 'final_table' for these 4 groups.

# e.g. final_table might look like:
#    TFBS_group      intervals   pct_of_total  fimo_overlap   pct_fimo_total   ...
# 1  all_w_o_coad    327596      74.45         176258         40.06            ...
# 2  coad_only       39422       8.96          20228          ...
# 3  coad_plus_others  73387     16.67         47944          ...
# 4  common_all_8      10328     2.35          9918           ...

############################################
## 2) Create "COAD" row by summing the three sub-categories
############################################
# We'll do it purely by arithmetic addition, 
# not by union, so the row shows e.g. 39422+73387+10328=123137 for intervals, 
# and fimo overlap e.g. 20228+47944+9918=75764

sub_coad_only       <- filter(final_table, TFBS_group=="coad_only")
sub_coad_plus_others<- filter(final_table, TFBS_group=="coad_plus_others")
sub_common_all_8    <- filter(final_table, TFBS_group=="common_all_8")

coad_intervals <- sum(sub_coad_only$intervals,
                      sub_coad_plus_others$intervals,
                      sub_common_all_8$intervals)

coad_fimo_overlap <- sum(sub_coad_only$fimo_overlap,
                         sub_coad_plus_others$fimo_overlap,
                         sub_common_all_8$fimo_overlap)

# We'll define total_n = 440022 or whatever your grand total is
total_n <- 440022

## Compute the new row
coad_row <- data.frame(
  TFBS_group      = "COAD",
  intervals       = coad_intervals,
  pct_of_total    = 100 * coad_intervals / total_n,
  fimo_overlap    = coad_fimo_overlap,
  pct_fimo_total  = 100 * coad_fimo_overlap / total_n,
  # The 'fimo_exclude' is intervals - fimo_overlap
  fimo_exclude    = coad_intervals - coad_fimo_overlap,
  pct_exclude_total = 100 * (coad_intervals - coad_fimo_overlap) / total_n,
  stringsAsFactors = FALSE
)

############################################
## 3) Insert that row in the final_table
############################################

final_table_summed <- rbind(
  final_table,
  coad_row
) %>%
  # if needed, reorder
  arrange(match(TFBS_group, c("all_w_o_coad","coad_only","coad_plus_others","common_all_8","COAD")))

print(final_table_summed)


```
```{r}
# 1) Combine subcategories for the real COAD union
coad_union <- reduce(c(coad_only, coad_plus_others, common_all_8))

# 2) all_w_o_coad is already a single set
all_w_o_coad <- reduce(all_w_o_coad)  # in case not yet reduced

# 3) Entire union of all 8
union_all_8 <- reduce(c(coad_union, all_w_o_coad))

# 4) Overlap with FIMO
coad_union_fimo <-  filter_by_fimo(coad_union, CTCF_hg38_reduce)
all_w_o_coad_fimo <-  filter_by_fimo(all_w_o_coad, CTCF_hg38_reduce)
union_all_8_fimo <-  filter_by_fimo(union_all_8, CTCF_hg38_reduce)

# 5) Table values
n_coad  <- length(coad_union)
n_coad_fimo <- length(coad_union_fimo)
n_coad_excl <- n_coad - n_coad_fimo

n_allwo  <- length(all_w_o_coad)
n_allwo_fimo <- length(all_w_o_coad_fimo)
n_allwo_excl <- n_allwo - n_allwo_fimo

n_total  <- length(union_all_8)
n_total_fimo <- length(union_all_8_fimo)
n_total_excl <- n_total - n_total_fimo

print(paste("n_coad:", n_coad))
print(paste("n_coad_fimo:", n_coad_fimo))
print(paste("n_coad_excl:", n_coad_excl))

print(paste("n_allwo:", n_allwo))
print(paste("n_allwo_fimo:", n_allwo_fimo))
print(paste("n_allwo_excl:", n_allwo_excl))

print(paste("n_total:", n_total))
print(paste("n_total_fimo:", n_total_fimo))
print(paste("n_total_excl:", n_total_excl))
```



```{r}
############################################
## 1) Create 'in_fimo' Column
############################################
library(GenomicRanges)
library(dplyr)

# Convert pairsDt to a GRanges for overlap
pairs_gr <- GRanges(
  seqnames = pairsDt$chrom,
  ranges = IRanges(start = pairsDt$start, end = pairsDt$end),
  ctcf_idx = pairsDt$ctcf_idx
)

seqlevelsStyle(pairs_gr) <- "UCSC"  # if needed

# Overlap with FIMO intervals
fimo_hits <- findOverlaps(pairs_gr, CTCF_hg38_reduce)
in_fimo_idx <- unique(queryHits(fimo_hits))

# Create a logical vector
in_fimo_logical <- rep(FALSE, length(pairs_gr))
in_fimo_logical[in_fimo_idx] <- TRUE

# Add to pairsDt
pairsDt$in_fimo <- in_fimo_logical

############################################
## 2) Filter out coverage <5 or invalid pwd
############################################
pairs_filtered <- pairsDt %>%
  filter(
    sum_coverage > 4,
    s2.sum_coverage > 4,
    !is.na(pwd),
    is.finite(pwd)
  )

############################################
## 3) Split into 'fimo_included' vs. 'fimo_excluded'
############################################
fimo_included_df <- pairs_filtered %>% filter(in_fimo)
fimo_excluded_df <- pairs_filtered %>% filter(!in_fimo)

############################################
## 4) Summarize Each Group’s Average PWD
############################################
summary_incl <- fimo_included_df %>%
  summarize(
    n_intervals = n(),
    avg_pwd = mean(pwd, na.rm = TRUE)
  )

summary_excl <- fimo_excluded_df %>%
  summarize(
    n_intervals = n(),
    avg_pwd = mean(pwd, na.rm = TRUE)
  )

cat("FIMO-Included intervals:\n")
print(summary_incl)

cat("FIMO-Excluded intervals:\n")
print(summary_excl)

# Alternatively, if you want group-by-group breakdown:
group_summary <- pairs_filtered %>%
  group_by(cancer_type, in_fimo) %>%
  summarize(
    n_intervals = n(),
    avg_pwd = mean(pwd, na.rm = TRUE)
  )
print(group_summary)

############################################
## 5) Statistical Test (Optional)
############################################
# e.g. unpaired t-test comparing PWD distributions
# for fimo_included vs. excluded across all intervals
t_out <- t.test(fimo_included_df$pwd, fimo_excluded_df$pwd, var.equal=FALSE)
cat("p-value for difference in PWD (FIMO included vs excluded):", t_out$p.value, "\n")

# If you want it per group:
results_by_group <- list()
for(g in c("common_all_8", "coad_only", "coad_plus_others", "all_w_o_coad")) {
  sub_incl <- filter(pairs_filtered, cancer_type==g, in_fimo==TRUE)
  sub_excl <- filter(pairs_filtered, cancer_type==g, in_fimo==FALSE)
  if(nrow(sub_incl)>0 & nrow(sub_excl)>0) {
    ttest_g <- t.test(sub_incl$pwd, sub_excl$pwd, var.equal=FALSE)
    results_by_group[[g]] <- ttest_g$p.value
  } else {
    results_by_group[[g]] <- NA
  }
}
print(results_by_group)

```





